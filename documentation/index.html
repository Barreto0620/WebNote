<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transfer Automation - Documentação</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'><path fill='%23004B87' d='M64 480H448c35.3 0 64-28.7 64-64V160c0-35.3-28.7-64-64-64H288L224 32H64C28.7 32 0 60.7 0 96V416c0 35.3 28.7 64 64 64z'/></svg>">
    
    <link rel="stylesheet" href="style.css">
    
    <style>
        .back-to-top {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: #004B87;
            color: white;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s, transform 0.3s;
            z-index: 1000;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .back-to-top.show {
            opacity: 1;
            visibility: visible;
        }

        .back-to-top:hover {
            transform: scale(1.1);
        }

        /* Reading Progress Bar */
        .reading-progress-bar {
            position: fixed;
            top: 0;
            left: 0;
            height: 4px; /* Adjust thickness as needed */
            background-color: #004B87; /* Match your brand color */
            width: 0%;
            z-index: 9999;
            transition: width 0.2s ease-out;
        }
        
        /* Video Container */
        .video-container {
            position: relative;
            padding-bottom: 56.25%; /* 16:9 aspect ratio */
            height: 0;
            overflow: hidden;
            border-radius: 8px; /* Optional: adds rounded corners to the video */
            margin: 20px auto; /* Centraliza o vídeo horizontalmente */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            max-width: 900px; /* Adiciona uma largura máxima */
        }
        
        .video-container iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: 0;
        }
    </style>
</head>
<body>
    <div id="reading-progress-bar" class="reading-progress-bar"></div>

    <header class="header">
        <div class="header-content">
            <a href="#overview" class="logo">
                <div class="logo-icon">
                    <img src="img/logo_webcash.png" alt="Logo Creator QRCode" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                    <svg viewBox="0 0 32 32" style="display: none;">
                        <rect width="32" height="32" rx="6" fill="#3498db"/>
                        <rect x="4" y="4" width="24" height="24" rx="2" fill="white"/>
                        <rect x="6" y="6" width="4" height="4" fill="#3498db"/>
                        <rect x="22" y="6" width="4" height="4" fill="#3498db"/>
                        <rect x="6" y="22" width="4" height="4" fill="#3498db"/>
                        <rect x="12" y="8" width="8" height="2" fill="#3498db"/>
                        <rect x="8" y="12" width="2" height="8" fill="#3498db"/>
                        <rect x="14" y="14" width="4" height="4" fill="#3498db"/>
                        <rect x="20" y="12" width="2" height="8" fill="#3498db"/>
                        <rect x="12" y="22" width="8" height="2" fill="#3498db"/>
                    </svg>
                </div>
                <span class="logo-text">Transfer Automation</span>
            </a>
            
            <div class="header-actions">
                <button class="theme-toggle" onclick="toggleTheme()">
                    <i id="theme-icon" class="fas fa-moon"></i>
                    <span id="theme-text">Dark</span>
                </button>
                <button class="mobile-menu-btn" onclick="toggleMobileMenu()">
                    <i class="fas fa-bars"></i>
                </button>
            </div>
        </div>
    </header>

    <div class="mobile-overlay" onclick="closeMobileMenu()"></div>

    <nav class="sidebar" id="sidebar">
        <div class="sidebar-content">
            <h2 class="sidebar-title">Documentação</h2>
            <ul class="nav-menu">
                <li class="nav-item">
                    <a href="#intro" class="nav-link" onclick="closeMobileMenu()">
                        <i class="fas fa-book-open"></i>
                        Introdução
                    </a>
                </li>
                <li class="nav-item">
                    <a href="#chapter1" class="nav-link" onclick="closeMobileMenu()">
                        <i class="fas fa-keyboard"></i>
                        Capítulo 1: Interactive User Input
                    </a>
                </li>
                <li class="nav-item">
                    <a href="#chapter2" class="nav-link" onclick="closeMobileMenu()">
                        <i class="fas fa-cogs"></i>
                        Capítulo 2: Transfer Workflow Orchestrator
                    </a>
                </li>
                <li class="nav-item">
                    <a href="#chapter3" class="nav-link" onclick="closeMobileMenu()">
                        <i class="fas fa-table"></i>
                        Capítulo 3: Spreadsheet Data Manager
                    </a>
                </li>
                <li class="nav-item">
                    <a href="#chapter4" class="nav-link" onclick="closeMobileMenu()">
                        <i class="fas fa-robot"></i>
                        Capítulo 4: UI Automation Engine
                    </a>
                </li>
                <li class="nav-item">
                    <a href="#chapter5" class="nav-link" onclick="closeMobileMenu()">
                        <i class="fas fa-window-maximize"></i>
                        Capítulo 5: Windows Dialog Handler
                    </a>
                </li>
                 <li class="nav-item">
                    <a href="#chapter6" class="nav-link" onclick="closeMobileMenu()">
                        <i class="fas fa-file-alt"></i>
                        Capítulo 6: Operational Logging & Reporting
                    </a>
                </li>
            </ul>
        </div>
    </nav>

    <main class="main" id="main">
        <div class="content">
            <section id="intro" class="section">
                <div class="hero">
                    <div class="hero-content">
                        <h1>Documentação: Transfer automation</h1>
                        <p>Este projeto é como um <strong>assistente digital</strong> que <em>automatiza</em> a tediosa tarefa de mover arquivos e pastas no seu computador. Ele lê todas as instruções de transferência de uma <em>planilha</em>, depois usa <strong>ações simuladas de mouse e teclado</strong> para copiar itens de um local e colá-los em outro, até mesmo lidando com complicadas <em>janelas pop-up</em> como prompts de segurança ou avisos "substituir arquivo". Finalmente, ele mantém um <em>log</em> detalhado de tudo o que fez e atualiza a planilha original.</p>
                        
                        <div class="video-container">
                            <iframe 
                                src="https://www.youtube.com/embed/wk62Oqq6JTs" 
                                title="Managed File Transfer Automation Isn't as Complex as You Think" 
                                frameborder="0" 
                                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
                                allowfullscreen>
                            </iframe>
                        </div>

                        <div class="features-grid">
                            <div class="feature-card">
                                <div class="feature-icon">
                                    <i class="fas fa-keyboard"></i>
                                </div>
                                <h4>Automação de UI</h4>
                                <p>Simula ações de mouse e teclado para interagir com a interface gráfica</p>
                            </div>
                            <div class="feature-card">
                                <div class="feature-icon">
                                    <i class="fas fa-table"></i>
                                </div>
                                <h4>Gerenciamento de Dados</h4>
                                <p>Lê e atualiza planilhas automaticamente com status das transferências</p>
                            </div>
                            <div class="feature-card">
                                <div class="feature-icon">
                                    <i class="fas fa-file-alt"></i>
                                </div>
                                <h4>Logging Completo</h4>
                                <p>Registra todas as operações com timestamps para auditoria</p>
                            </div>
                        </div>
                    </div>
                </div>
            </section>
            
            <section id="chapter1" class="section">
                <h1>Capítulo 1: Interactive User Input</h1>
                
                <div class="content-box highlight">
                    <p>Bem-vindo ao projeto <strong>Transfer Automation</strong>! Esta ferramenta é projetada para tornar sua vida mais fácil, copiando e colando automaticamente arquivos e pastas com base em uma lista simples que você fornece. Mas antes de começar sua mágica, ela precisa de algumas informações suas.</p>
                </div>

                <p>Pense assim: se você contratar alguém para fazer um trabalho, primeiro você precisa dizer a essa pessoa <em>o que</em> fazer e <em>onde</em> encontrar as instruções, certo? Nosso script de automação é semelhante. Ele precisa saber:</p>

                <div class="professional-list">
                    <ul>
                        <li><strong>Onde está a lista de arquivos para transferir?</strong> (Esta lista geralmente está em uma planilha).</li>
                        <li><strong>Preciso de nome de usuário e senha para acessar pastas de rede?</strong> (Às vezes, unidades de rede são bloqueadas e precisam de credenciais).</li>
                    </ul>
                </div>

                <p>É aqui que entra a parte <strong>Interactive User Input</strong> do nosso projeto! Seu trabalho principal é <strong>fazer essas perguntas essenciais</strong> logo no início, usando janelas pop-up simples. Dessa forma, o script obtém todos os detalhes necessários para começar seu trabalho.</p>

                <h3>Como Ele Pergunta por Informações?</h3>
                <p>O componente "Interactive User Input" usa uma ferramenta especial chamada <code>tkinter</code> (pronuncia-se "tee-kay-inter"). <code>tkinter</code> é uma parte padrão do Python que ajuda a criar janelas gráficas simples e botões. Para nosso projeto, usamos seu recurso <code>simpledialog</code>, que é perfeito para fazer perguntas rápidas através de pequenas caixas pop-up.</p>

                <div class="content-box success">
                    <p>Quando você executa o script de automação, verá janelas pop-up como estas:
                    <br>• Primeiro, uma janela perguntando pelo caminho da sua planilha.
                    <br>• Em seguida, janelas perguntando por um nome de usuário e senha opcionais.</p>
                </div>

                <h3>Obtendo o Caminho da Planilha</h3>
                <p>A primeira informação que o script precisa é a localização da sua planilha. Esta planilha é como o "cérebro" da operação, dizendo ao script exatamente o que copiar e onde colar.</p>

                <div class="code-block">
                    <div class="code-header">
                        <i class="fas fa-code"></i>
                        Exemplo de Código - Solicitação de Caminho
                    </div>
                    <pre><code>import tkinter as tk
from tkinter import simpledialog

# Prepara o sistema pop-up (escondemos a janela principal)
root = tk.Tk()
root.withdraw() # Esta linha esconde a janela principal vazia

# Pergunta ao usuário pelo caminho da planilha
sheet_path = simpledialog.askstring(
    title="Caminho da Planilha", # Este é o título da janela pop-up
    prompt="Diga-me onde está sua planilha (ex: C:\\dados\\minhas_tarefas.xlsx):"
)

# Um pequeno truque: se você copiar-colar um caminho, pode adicionar aspas.
# Esta linha as remove se existirem.
sheet_path = sheet_path.strip('"') if sheet_path else None</code></pre>
                </div>

                <h3>Perguntando por Nome de Usuário e Senha (Opcional)</h3>
                <p>Às vezes, os arquivos ou pastas que você precisa acessar estão em uma unidade de rede que requer login. Nosso script pode lidar com isso também! Ele pode pedir seu nome de usuário e senha, que então usa para fazer login automaticamente se solicitado durante a transferência.</p>

                <div class="professional-list">
                    <ul>
                        <li><strong>Nome de usuário:</strong> Solicitado através de uma caixa de diálogo simples</li>
                        <li><strong>Senha:</strong> Usa <code>show="*"</code> para ocultar a digitação por segurança</li>
                        <li><strong>Limpeza:</strong> <code>root.destroy()</code> fecha o sistema de janelas quando terminar</li>
                    </ul>
                </div>

                <h3>Como Tudo se Encaixa</h3>
                <p>O componente "Interactive User Input" atua como um entrevistador amigável, coletando todos os fatos iniciais que o script de automação precisa de você através do sistema de janelas pop-up.</p>

                <div class="content-box important">
                    <p><strong>No código real:</strong> Esta interação pode ser encontrada em <code>main.py</code> na seção marcada como <code>Diálogos de entrada</code> (que significa "Diálogos de Entrada" em português). Ela usa <code>tkinter</code> para criar essas janelas pop-up, obtém sua entrada e armazena em variáveis para o resto do script usar.</p>
                </div>
            </section>
            
            <section id="chapter2" class="section">
                <h1>Capítulo 2: Transfer Workflow Orchestrator</h1>

                <div class="content-box">
                    <p>Bem-vindo de volta! No <strong>Capítulo 1</strong>, aprendemos como nossa ferramenta de automação coleta as informações essenciais que precisa para começar. Agora que o script tem suas instruções, é hora de falar sobre o "cérebro" da operação: o <strong>Transfer Workflow Orchestrator</strong>.</p>
                </div>

                <p>Imagine que você deu a um gerente de projeto uma longa lista de tarefas para completar. Este gerente precisa:</p>
                <div class="professional-list">
                    <ul>
                        <li>Percorrer a lista item por item.</li>
                        <li>Designar cada tarefa ao membro correto da equipe.</li>
                        <li>Acompanhar o que está feito, o que foi pulado e o que deu errado.</li>
                        <li>Garantir que todo o projeto avance suavemente.</li>
                    </ul>
                </div>

                <p>Isso é exatamente o que o <strong>Transfer Workflow Orchestrator</strong> faz pelo nosso projeto! É o "gerente de projeto" que pega sua lista de arquivos para transferir e garante que cada um seja tratado corretamente do início ao fim.</p>

                <h3>Que Problema Ele Resolve?</h3>
                <div class="content-box highlight">
                    <p>Digamos que você tenha uma planilha com 100 itens para copiar de diferentes lugares para diferentes destinos. Fazer isso manualmente seria tedioso, propenso a erros, e você pode perder o controle do seu progresso. O Orchestrator resolve isso:</p>
                </div>

                <div class="professional-list">
                    <ul>
                        <li><strong>Processamento Sistemático:</strong> Garante que cada item da sua lista seja tentado. Sem mais arquivos esquecidos!</li>
                        <li><strong>Tratamento de Erros:</strong> Se uma transferência falha, ele captura o erro e o marca, então você sabe exatamente quais itens precisam de atenção.</li>
                        <li><strong>Acompanhamento de Progresso:</strong> Mantém a contagem de quantos itens foram movidos com sucesso, quantos foram pulados e quantos falharam.</li>
                    </ul>
                </div>

                <h3>Como Funciona? O "Gerente de Projeto" em Ação</h3>
                <p>O trabalho principal do Transfer Workflow Orchestrator é guiar todo o processo de transferência. Ele não faz a cópia-colagem real (esse é o trabalho do UI Automation Engine), mas diz <em>o que</em> copiar, <em>onde</em> colar e <em>quando</em>.</p>

                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>Responsabilidade</th>
                                <th>Descrição</th>
                                <th>Resultado</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Recebe Lista de Tarefas</strong></td>
                                <td>Obtém a lista completa de tarefas (linhas da planilha)</td>
                                <td>Conhece todas as transferências necessárias</td>
                            </tr>
                            <tr>
                                <td><strong>Itera Através das Tarefas</strong></td>
                                <td>Percorre cada linha da planilha, uma por uma</td>
                                <td>Processamento sistemático de todos os itens</td>
                            </tr>
                            <tr>
                                <td><strong>Delega Trabalho</strong></td>
                                <td>Para cada tarefa, diz ao UI Automation Engine para executar as ações</td>
                                <td>Transferências executadas automaticamente</td>
                            </tr>
                            <tr>
                                <td><strong>Gerencia Progresso</strong></td>
                                <td>Atualiza constantemente contadores internos para tarefas processadas, puladas e falhadas</td>
                                <td>Visibilidade completa do status da operação</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3>O Loop Principal</h3>
                <div class="code-block">
                    <div class="code-header">
                        <i class="fas fa-cogs"></i>
                        Conceito do Loop Principal
                    </div>
                    <pre><code># Imagine 'todas_minhas_tarefas_transferencia' é uma lista de tarefas
todas_minhas_tarefas_transferencia = [
    {"origem": "arquivo_a.txt", "destino": "pasta_x"},
    {"origem": "pasta_b", "destino": "pasta_y"},
    # ... muitas mais tarefas ...
]

processadas = puladas = erros = 0

for tarefa in todas_minhas_tarefas_transferencia:
    # O Orchestrator faz sua mágica aqui para cada tarefa!
    if tarefa.get("status") == "OK":
        print(f"Pulando '{tarefa['origem']}' - já feito!")
        puladas += 1
    else:
        try:
            print(f"Tentando copiar '{tarefa['origem']}' para '{tarefa['destino']}'...")
            # Aqui o Orchestrator normalmente diria ao UI Automation Engine para trabalhar
            print("Sucesso!")
            tarefa["status"] = "OK" # Atualiza status
            processadas += 1
        except Exception as e:
            print(f"Falhou! Erro: {e}")
            tarefa["status"] = "ERRO" # Marca como erro
            erros += 1

print(f"\nResumo: Processadas: {processadas}, Puladas: {puladas}, Erros: {erros}")</code></pre>
                </div>

                <h3>O Orchestrator no main.py</h3>
                <div class="content-box important">
                    <p>No script <code>main.py</code>, o trabalho do Orchestrator é principalmente tratado em uma seção chamada <code>Loop principal</code>. É onde o programa percorre cada linha da sua planilha, verifica o status, delega para o UI Automation Engine, e gerencia contadores de sucesso/falha.</p>
                </div>

                <p>Este loop sistemático é o coração do "Transfer Workflow Orchestrator", garantindo que cada item da sua lista seja abordado, erros sejam capturados e o progresso seja rastreado de forma transparente.</p>
            </section>
            
            <section id="chapter3" class="section">
                <h1>Capítulo 3: Spreadsheet Data Manager</h1>

                <div class="content-box highlight">
                    <p>Bem-vindo de volta! Aprendemos como nossa ferramenta de automação pergunta pelo caminho da sua planilha especial, e como o "Orchestrator" atua como um gerente de projeto, guiando todo o processo de transferência usando as instruções dessa planilha.</p>
                </div>

                <p>Mas como exatamente o script de automação <em>lê</em> sua planilha? Como ele entende o que copiar e onde colar? E como ele atualiza sua planilha para mostrar quais tarefas estão feitas ou têm erros?</p>

                <p>É aqui que entra o <strong>Spreadsheet Data Manager</strong>! Pense nele como o "bibliotecário" ou "especialista em dados" do projeto. Seu trabalho é manipular eficientemente todas as informações em sua planilha, garantindo que o resto do script tenha instruções precisas e atualizadas.</p>

                <h3>Que Problema Ele Resolve?</h3>
                <p>Imagine que suas tarefas de transferência estão escritas em uma longa lista. Para nosso script de automação funcionar, ele precisa:</p>

                <div class="professional-list">
                    <ul>
                        <li><strong>Ler a Lista:</strong> Abrir o arquivo da planilha e entender todas as linhas e colunas.</li>
                        <li><strong>Organizar Informações:</strong> Selecionar pedaços específicos de informação, como "de onde copiar" e "para onde colar".</li>
                        <li><strong>Atualizar Progresso:</strong> Se uma tarefa for completada, ela precisa ser marcada como "feita". Se falhar, precisa ser marcada com "erro".</li>
                        <li><strong>Salvar Mudanças:</strong> Garantir que todas essas marcas "feita" ou "erro" sejam salvas de volta na sua planilha para a próxima vez.</li>
                    </ul>
                </div>

                <div class="content-box success">
                    <p>Fazer isso manualmente para centenas de itens é tedioso e propenso a erros. O <strong>Spreadsheet Data Manager</strong> automatiza todos esses passos, garantindo que o script sempre tenha a lista de tarefas mais recente e possa atualizá-la de forma confiável.</p>
                </div>

                <h3>Começando: Sua Planilha de Instruções</h3>
                <p>O coração do Spreadsheet Data Manager é seu arquivo de instruções. Este pode ser um arquivo <strong>CSV</strong> (Valores Separados por Vírgula) ou <strong>XLSX</strong> (Excel).</p>

                <p>Ele precisa ter pelo menos duas colunas principais:</p>
                <div class="professional-list">
                    <ul>
                        <li><strong>COPIAR (COPY FROM):</strong> Esta coluna contém o caminho completo para o arquivo ou pasta que você quer copiar.</li>
                        <li><strong>COLAR (PASTE TO):</strong> Esta coluna contém o caminho completo para a pasta de destino onde você quer colar o item.</li>
                    </ul>
                </div>

                <p>Também pode ter uma terceira coluna opcional:</p>
                <div class="professional-list">
                    <ul>
                        <li><strong>STATUS:</strong> Esta coluna é onde o script de automação escreve seu progresso. Dirá "OK" para transferências bem-sucedidas e "ERRO" se algo deu errado.</li>
                    </ul>
                </div>

                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>COPIAR</th>
                                <th>COLAR</th>
                                <th>STATUS</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>C:\MeusDocumentos\Relatorio.pdf</td>
                                <td>\\CompartilhamentoRede\Relatorios\</td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>D:\Fotos\Ferias\</td>
                                <td>C:\Backup\MinhasFotos\</td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>E:\Musica\Musica.mp3</td>
                                <td>\\OutroPC\MinhaMusica\</td>
                                <td>OK</td>
                            </tr>
                            <tr>
                                <td>C:\Dados\Arquivo.zip</td>
                                <td>\\Servidor\Arquivo\</td>
                                <td></td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3>Como Funciona? O "Especialista em Dados"</h3>
                <p>O Spreadsheet Data Manager usa uma biblioteca Python muito popular e poderosa chamada <code>pandas</code>. <code>pandas</code> é como um programa de planilha super-inteligente para Python. Nos permite ler, organizar e alterar dados em tabelas muito facilmente.</p>

                <div class="code-block">
                    <div class="code-header">
                        <i class="fas fa-table"></i>
                        Carregamento de Dados
                    </div>
                    <pre><code>import pandas as pd

# Imagine 'caminho_planilha' é "C:\tarefas.xlsx" do Capítulo 1
caminho_planilha = "C:\\tarefas.xlsx" # Para nosso exemplo

# Exemplo: Carregando um arquivo Excel
if caminho_planilha.lower().endswith(".xlsx"):
    df = pd.read_excel(caminho_planilha, dtype=str, engine="openpyxl")
    print("Dados carregados do Excel!")
# Exemplo: Carregando um arquivo CSV
elif caminho_planilha.lower().endswith(".csv"):
    df = pd.read_csv(caminho_planilha, dtype=str)
    print("Dados carregados do CSV!")
else:
    print("Tipo de arquivo não suportado!")

# 'df' agora contém todos os dados da sua planilha!</code></pre>
                </div>

                <h3>Organização de Colunas</h3>
                <p>Após carregar os dados, o Data Manager organiza as colunas para facilitar o trabalho. Ele padroniza os nomes das colunas (converte para maiúsculas) e verifica se as colunas importantes "COPIAR" e "COLAR" existem. Se a coluna "STATUS" estiver faltando, ele cria uma vazia.</p>

                <div class="content-box important">
                    <p><strong>Normalização:</strong> O sistema converte todos os nomes de colunas para maiúsculas para consistência, então seja você digitou "copiar" ou "COPIAR" na sua planilha, o script sempre encontrará "COPIAR".</p>
                </div>

                <h3>Atualização de Status e Salvamento</h3>
                <p>Conforme o Transfer Workflow Orchestrator completa ou falha tarefas, o Spreadsheet Data Manager atualiza a coluna <code>STATUS</code> para essa linha específica no DataFrame. Após todas as transferências serem tentadas, ele salva todo o DataFrame atualizado de volta no seu arquivo de planilha original.</p>

                <div class="professional-list">
                    <ul>
                        <li><strong>Sucesso:</strong> <code>df.at[linha, "STATUS"] = "OK"</code></li>
                        <li><strong>Erro:</strong> <code>df.at[linha, "STATUS"] = "ERRO"</code></li>
                        <li><strong>Salvamento:</strong> <code>df.to_excel()</code> ou <code>df.to_csv()</code> baseado no tipo do arquivo original</li>
                    </ul>
                </div>

                <div class="content-box success">
                    <p><strong>Persistência:</strong> Este salvamento é crucial porque torna os status "OK" e "ERRO" permanentes para sua próxima execução. Se você executar o script novamente, ele pulará automaticamente os itens já marcados como "OK"!</p>
                </div>
            </section>
            
            <section id="chapter4" class="section">
                <h1>Capítulo 4: UI Automation Engine</h1>

                <div class="content-box">
                    <p>Bem-vindo de volta! Vimos como nossa ferramenta de automação coleta informações essenciais de você, organiza e gerencia todo o processo de transferência, e lê/atualiza sua lista de tarefas. Mas como o script realmente <em>faz</em> o copiar e colar? Como ele interage com a tela do seu computador, abre pastas, seleciona arquivos e pressiona "Ctrl+C" ou "Ctrl+V"?</p>
                </div>

                <p>É aqui que entra o <strong>UI Automation Engine</strong>! Pense nele como as "mãos e olhos" do script para a interface gráfica do seu computador (UI significa Interface do Usuário). Permite que nosso script de automação atue exatamente como um usuário humano, imitando suas teclas pressionadas e movimentos do mouse para fazer as coisas acontecerem na tela.</p>

                <h3>Que Problema Ele Resolve?</h3>
                <p>Imagine que você precisa copiar manualmente um arquivo de <code>C:\Relatorios\Mensal.xlsx</code> para <code>\\CompartilhamentoRede\Arquivos\</code>. Você faria:</p>
                <div class="professional-list">
                    <ul>
                        <li>Abrir o Explorador de Arquivos.</li>
                        <li>Navegar para <code>\\CompartilhamentoRede\Arquivos\</code>.</li>
                        <li>Pressionar <code>Ctrl + V</code> (Colar).</li>
                        <li>Se um diálogo "Substituir Arquivo" aparecer, você pode pressionar "Enter" para confirmar.</li>
                    </ul>
                </div>

                <div class="content-box highlight">
                    <p>Fazer isso manualmente para muitos arquivos é cansativo e propenso a erros. O <strong>UI Automation Engine</strong> resolve isso permitindo que o script execute todas essas mesmas ações automaticamente, direto na sua tela! É a camada fundamental que torna possível a cópia e colagem automatizadas.</p>
                </div>

                <h3>As "Mãos e Olhos" do Engine</h3>
                <p>O UI Automation Engine depende de duas principais bibliotecas Python para fazer sua mágica:</p>

                <div class="professional-list">
                    <ul>
                        <li><strong>`pyautogui` (As Mãos):</strong> Esta biblioteca é como as "mãos" do script. Pode simular teclas pressionadas (como digitar letras, pressionar "Enter", ou atalhos como "Ctrl+C") e até mover/clicar o mouse. Para nosso projeto, é principalmente usado para ações de teclado.</li>
                        <li><strong>`pygetwindow` (Os Olhos):</strong> Esta biblioteca é como os "olhos" do script. Permite que o script encontre janelas específicas que estão abertas na sua tela (como uma janela do Explorador de Arquivos ou um prompt de login "Segurança do Windows"). Também pode tornar uma janela encontrada ativa, para que `pyautogui` saiba onde "digitar".</li>
                    </ul>
                </div>

                <h3>Como Funciona: Executando uma Cópia/Colagem</h3>
                <p>Vamos quebrar como o UI Automation Engine executa a tarefa principal de copiar e colar, passo a passo, imitando um usuário humano.</p>

                <h4>1. Abrindo um Caminho (Origem ou Destino)</h4>
                <p>Para copiar ou colar, o script primeiro precisa abrir a pasta correta ou selecionar um arquivo. O UI Automation Engine faz isso "digitando" um comando no diálogo "Executar" (que você pode abrir com <code>Win + R</code>).</p>

                <div class="code-block">
                    <div class="code-header">
                        <i class="fas fa-robot"></i>
                        Exemplo - Abertura de Caminho
                    </div>
                    <pre><code>import pyautogui as pg
import pygetwindow as gw
import time # Usado para pausar o script brevemente

# --- Parte 1: Executando um comando (ex: abrir Explorador de Arquivos) ---
def executar_comando(cmd: str):
    pg.hotkey("winleft", "r") # Pressiona Win + R para abrir diálogo 'Executar'
    time.sleep(0.4)           # Pausa brevemente
    pg.write(cmd, interval=0.02) # Digite o comando (ex: 'explorer C:\')
    pg.press("enter")         # Pressiona Enter para executar o comando
    time.sleep(2)             # Espera a janela abrir
    return gw.getActiveWindow() # Obtém a janela recém-aberta

# --- Parte 2: Abrindo um caminho (pasta ou arquivo) ---
def abrir_caminho(caminho: str, usuario: str, senha: str):
    # Se é um arquivo, dizemos ao explorer para selecioná-lo
    # Se é uma pasta, apenas abrimos a pasta
    if "." in caminho.split(os.sep)[-1]: # Verificação simplificada para extensão de arquivo
        win = executar_comando(f'explorer.exe /select,"{caminho}"')
    else: # É uma pasta
        win = executar_comando(f'explorer "{caminho}"')
        pg.hotkey("ctrl", "a") # Seleciona todo o conteúdo da pasta (opcional, para copiar conteúdo da pasta)
    return win</code></pre>
                </div>

                <h4>2. Copiando a Seleção</h4>
                <p>Uma vez que o caminho de origem está aberto e o item (arquivo ou pasta) está selecionado, o engine "pressiona" o comando universal de cópia: <code>Ctrl + C</code>.</p>

                <div class="code-block">
                    <div class="code-header">
                        <i class="fas fa-copy"></i>
                        Função de Cópia
                    </div>
                    <pre><code>def copiar_selecao(eh_pasta: bool):
    if eh_pasta:
        pg.hotkey("ctrl", "a") # Seleciona tudo na pasta para copiar (se for uma pasta)
    pg.hotkey("ctrl", "c")     # Pressiona Ctrl + C para copiar
    time.sleep(0.5)            # Pausa brevemente para a operação de cópia registrar</code></pre>
                </div>

                <h4>3. Colando no Destino</h4>
                <p>Após copiar, o script abre o caminho de destino (usando a mesma função <code>abrir_caminho</code>), e então "pressiona" <code>Ctrl + V</code> para colar. Uma parte crucial aqui é lidar com potenciais diálogos pop-up, como o prompt "Substituir ou Pular Arquivos" se um arquivo com o mesmo nome já existe.</p>

                <div class="code-block">
                    <div class="code-header">
                        <i class="fas fa-paste"></i>
                        Função de Colagem
                    </div>
                    <pre><code>def colar_na_pasta():
    pg.hotkey("ctrl", "v") # Pressiona Ctrl + V para colar
    time.sleep(0.5)        # Pausa brevemente
    lidar_dialogo_substituir() # Chama função para verificar e lidar com diálogos de substituição
    time.sleep(4)          # Espera a operação de colagem completar

def lidar_dialogo_substituir():
    # Lista de possíveis títulos para o diálogo "Substituir"
    titulos = ["Substituir ou Ignorar Arquivos", "Replace or Skip Files"]
    for _ in range(50): # Tenta por alguns segundos
        for t in titulos:
            if gw.getWindowsWithTitle(t): # Verifica se alguma janela com estes títulos existe
                pg.press("enter") # Se encontrada, pressiona Enter (geralmente significa "Substituir")
                time.sleep(0.5)
                return # Diálogo tratado, podemos parar de verificar
        time.sleep(0.15) # Espera um pouco antes de verificar novamente</code></pre>
                </div>

                <h3>O UI Automation Engine no main.py</h3>
                <div class="content-box important">
                    <p>No script <code>main.py</code> real, as funções que discutimos (<code>executar_comando</code>, <code>abrir_caminho</code>, <code>copiar_selecao</code>, <code>colar_na_pasta</code>, <code>lidar_dialogo_substituir</code>, e <code>popup_login</code>) são todas parte da seção "Utilitários".</p>
                </div>

                <p>O loop principal do Transfer Workflow Orchestrator chama essas funções:</p>

                <div class="code-block">
                    <div class="code-header">
                        <i class="fas fa-cogs"></i>
                        Integração no Loop Principal
                    </div>
                    <pre><code>for i, linha in df.iterrows():
    try:
        logging.info(f"[{i+1}/{len(df)}] Copiando {src} → {dst}")

        # O Orchestrator diz ao UI Automation Engine o que fazer:
        # 1. Abrir a localização de origem
        win_src = abrir_caminho(src, usuario, senha) # <-- UI Automation Engine em ação!
        # 2. Copiar o arquivo/pasta selecionado
        copiar_selecao(not eh_arquivo(src))          # <-- UI Automation Engine em ação!
        # 3. Abrir a localização de destino  
        win_dst = abrir_caminho(dst, usuario, senha) # <-- UI Automation Engine em ação!
        # 4. Colar o item copiado
        colar_na_pasta()                             # <-- UI Automation Engine em ação!

        df.at[i, "STATUS"] = "OK"
        processadas += 1
    except Exception as e:
        logging.error(f"Linha {i+1} erro: {e}")
        df.at[i, "STATUS"] = "ERRO"
        erros += 1</code></pre>
                </div>

                <h3>Configurações de Segurança</h3>
                <div class="content-box success">
                    <p><strong>Configurações importantes:</strong> <code>pyautogui.PAUSE = 0.15</code> e <code>pyautogui.FAILSAFE = True</code> são definidos no início do <code>main.py</code>:
                    <br>• <code>PAUSE</code>: Faz o script pausar 0.15 segundos após cada ação, essencial para o Windows reagir adequadamente
                    <br>• <code>FAILSAFE</code>: Move o mouse para qualquer canto da tela para parar o script imediatamente se necessário</p>
                </div>
            </section>
            
            <section id="chapter5" class="section">
                <h1>Capítulo 5: Windows Dialog Handler</h1>

                <div class="content-box highlight">
                    <p>Bem-vindo de volta! Aprendemos como nosso script usa suas "mãos" (<code>pyautogui</code>) e "olhos" (<code>pygetwindow</code>) para interagir diretamente com a tela do seu computador, abrindo pastas, copiando arquivos e colando-os. É como ter um assistente robô movendo seu mouse e digitando no seu teclado.</p>
                </div>

                <p>Mas o que acontece se este assistente robô tenta colar um arquivo, e de repente uma janela pop-up aparece perguntando: "Você quer substituir este arquivo?" Ou talvez ele tente abrir uma pasta de rede, e o Windows exibe um diálogo "Credenciais de Segurança" pedindo um nome de usuário e senha? Se nosso robô não souber como lidar com esses pop-ups, ele simplesmente travará!</p>

                <p>É aqui que entra o <strong>Windows Dialog Handler</strong>! Pense nele como um "solucionador de problemas" especializado ou "segurança" para o processo de automação. Seu trabalho é <strong>detectar e interagir automaticamente com janelas pop-up cruciais</strong> que podem interromper a transferência, garantindo que a automação continue suavemente sem travar.</p>

                <h3>Que Problema Ele Resolve?</h3>
                <p>Imagine que você está tentando copiar centenas de arquivos. Você solta sua automação, e ela está indo muito bem. Mas então, ela encontra um obstáculo:</p>

                <div class="professional-list">
                    <ul>
                        <li><strong>Cenário 1: Acesso à Rede.</strong> O script tenta abrir uma pasta em uma unidade de rede, e um diálogo "Segurança do Windows" aparece, exigindo um nome de usuário e senha. Se o script esperar por você, a automação para.</li>
                        <li><strong>Cenário 2: Arquivos Duplicados.</strong> O script tenta colar um arquivo, mas um arquivo com o mesmo nome já existe no destino. Um pop-up "Substituir ou Pular Arquivos" aparece, pedindo uma decisão. Novamente, o script está travado.</li>
                    </ul>
                </div>

                <div class="content-box important">
                    <p>Assistir manualmente e clicar nesses pop-ups para cada transferência seria tão tedioso quanto fazer as transferências manualmente! O <strong>Windows Dialog Handler</strong> resolve isso "assistindo" ativamente a essas janelas específicas e automaticamente tomando a ação necessária (como pressionar "Enter" ou digitar credenciais) para que a transferência possa prosseguir.</p>
                </div>

                <h3>Como Funciona: O "Solucionador de Problemas Pop-Up"</h3>
                <p>O Windows Dialog Handler trabalha em estreita colaboração com o UI Automation Engine para monitorar e reagir a janelas pop-up. Ele usa principalmente <code>pygetwindow</code> para "ver" se uma janela específica está aberta e <code>pyautogui</code> para "agir" simulando teclas pressionadas.</p>

                <h4>1. Lidando com Diálogos "Substituir ou Pular Arquivos"</h4>
                <p>Quando você copia um arquivo e o cola em uma pasta onde um arquivo com o mesmo nome já existe, o Windows geralmente mostra um pop-up perguntando se você quer "Substituir os arquivos no destino," "Pular este arquivo," ou "Deixe-me decidir." Nossa automação geralmente quer "Substituir," que é frequentemente a opção padrão quando você pressiona "Enter."</p>

                <div class="code-block">
                    <div class="code-header">
                        <i class="fas fa-window-maximize"></i>
                        Tratamento de Diálogos de Substituição
                    </div>
                    <pre><code>import pyautogui as pg
import pygetwindow as gw
import time

def lidar_dialogo_substituir():
    # Lista de títulos comuns para o diálogo "Substituir"
    titulos = ["Substituir ou Ignorar Arquivos", "Replace or Skip Files"]
    for _ in range(50): # Tenta verificar por alguns segundos (50 * 0.15s)
        for t in titulos:
            if gw.getWindowsWithTitle(t): # Verifica se alguma janela com estes títulos existe
                pg.press("enter") # Se encontrada, pressiona a tecla Enter
                time.sleep(0.5)   # Dá um momento para o Windows reagir
                return            # Diálogo tratado, podemos parar de verificar
        time.sleep(0.15) # Espera um pouco antes de verificar novamente</code></pre>
                </div>

                <h4>2. Lidando com Diálogos "Segurança do Windows" (Login de Rede)</h4>
                <p>Se seu script precisa acessar uma unidade de rede ou um recurso protegido, o Windows pode exibir uma janela "Segurança do Windows" ou "Credenciais de Rede" pedindo um nome de usuário e senha.</p>

                <div class="code-block">
                    <div class="code-header">
                        <i class="fas fa-shield-alt"></i>
                        Tratamento de Login de Rede
                    </div>
                    <pre><code>def popup_login(usuario: str, senha: str):
    if not usuario or not senha: # Se nenhuma credencial fornecida, pula
        return
    titulos = [
        "Segurança do Windows", "Windows Security", "Credenciais de Rede",
        "Network Credentials", "Controle de Conta de Usuário", "User Account Control",
    ]
    for _ in range(60): # Tenta verificar por um período mais longo (60 * 0.15s)
        for t in titulos:
            if gw.getWindowsWithTitle(t): # Verifica se um diálogo de login existe
                pg.write(usuario)  # Digite o nome de usuário
                pg.press("tab")     # Pressiona Tab para mover para o campo da senha
                pg.write(senha)  # Digite a senha
                pg.press("enter")   # Pressiona Enter para fazer login
                time.sleep(1.5)     # Dá tempo para o Windows processar o login
                return              # Diálogo tratado
        time.sleep(0.15) # Espera um pouco antes de verificar novamente</code></pre>
                </div>

                <h3>O Papel do Dialog Handler no Fluxo</h3>
                <p>O Windows Dialog Handler é um auxiliar que o UI Automation Engine chama sempre que um pop-up pode ocorrer. É um componente proativo que evita que a automação trave em diálogos comuns do sistema.</p>

                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>Situação</th>
                                <th>Diálogo Esperado</th>
                                <th>Ação do Handler</th>
                                <th>Resultado</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Abrindo pasta de rede</td>
                                <td>"Segurança do Windows"</td>
                                <td>Digite usuário, Tab, senha, Enter</td>
                                <td>Acesso autenticado concedido</td>
                            </tr>
                            <tr>
                                <td>Colando arquivo existente</td>
                                <td>"Substituir ou Pular Arquivos"</td>
                                <td>Pressiona Enter (Substituir)</td>
                                <td>Arquivo substituído com sucesso</td>
                            </tr>
                            <tr>
                                <td>Operação sem conflitos</td>
                                <td>Nenhum diálogo</td>
                                <td>Nenhuma ação (timeout)</td>
                                <td>Operação continua normalmente</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3>O Windows Dialog Handler no main.py</h3>
                <div class="content-box success">
                    <p>No script <code>main.py</code>, as funções <code>popup_login</code> e <code>lidar_dialogo_substituir</code> são parte da seção "Utilitários":
                    <br>• <code>popup_login</code> é chamada dentro da função <code>abrir_caminho</code>
                    <br>• <code>lidar_dialogo_substituir</code> é chamada dentro da função <code>colar_na_pasta</code></p>
                </div>

                <p>Esta estrutura garante que o tratamento de diálogos seja integrado diretamente nas ações que podem disparar esses pop-ups. É como uma "rede de segurança" embutida que captura e resolve interrupções comuns, permitindo que o fluxo de automação principal prossiga sem intervenção manual.</p>

                <div class="professional-list">
                    <ul>
                        <li><strong>Integração Seamless:</strong> Os handlers são chamados automaticamente nos pontos apropriados</li>
                        <li><strong>Timeout Inteligente:</strong> Se nenhum diálogo aparece, o handler para de procurar após um período definido</li>
                        <li><strong>Suporte Multilíngue:</strong> Reconhece títulos de diálogos em português e inglês</li>
                        <li><strong>Tratamento Gracioso:</strong> Se credenciais não foram fornecidas, o handler simplesmente não tenta fazer login</li>
                    </ul>
                </div>
            </section>
            
            <section id="chapter6" class="section">
                <h1>Capítulo 6: Operational Logging & Reporting</h1>

                <div class="content-box">
                    <p>Bem-vindo de volta! Aprendemos como nosso script de automação lida inteligentemente com janelas pop-up inesperadas, garantindo que o processo de transferência não trave. Agora, imagine que nossa automação diligente tem estado executando, copiando arquivos e lidando com várias situações. Como sabemos o que realmente aconteceu? Todos os arquivos foram transferidos com sucesso? Houve erros? Quais foram pulados?</p>
                </div>

                <p>É aqui que entra o componente <strong>Operational Logging & Reporting</strong>! Pense nele como o <strong>"escrivão"</strong> e <strong>"repórter"</strong> do projeto. Ele diligentemente escreve tudo importante que acontece durante o trabalho da automação em um diário especial (um arquivo de log). Então, no final, ele compila um <strong>resumo</strong> organizado de toda sua operação e apresenta para você.</p>

                <h3>Que Problema Ele Resolve?</h3>
                <p>Quando uma automação executa, especialmente uma que executa muitas ações (como copiar centenas de arquivos), é crucial ter um registro claro de suas atividades. Sem logging e relatórios, você ficaria adivinhando:</p>

                <div class="professional-list">
                    <ul>
                        <li><strong>Ela começou?</strong> Ainda está executando?</li>
                        <li><strong>Quais arquivos foram processados?</strong></li>
                        <li><strong>Houve erros?</strong> Se sim, <em>onde</em> eles aconteceram?</li>
                        <li><strong>Quantos itens foram pulados?</strong></li>
                        <li><strong>Qual foi o resultado final?</strong></li>
                    </ul>
                </div>

                <div class="content-box highlight">
                    <p>O componente <strong>Operational Logging & Reporting</strong> resolve esses problemas:
                    <br>• <strong>Criando um registro detalhado:</strong> Cada ação significativa é gravada com timestamp
                    <br>• <strong>Fornecendo transparência:</strong> Você pode ver exatamente o que o script fez, passo a passo
                    <br>• <strong>Ajudando na solução de problemas:</strong> Se algo der errado, o arquivo de log ajuda a identificar o momento e motivo exatos do erro
                    <br>• <strong>Dando um resumo rápido:</strong> No final, você obtém uma visão clara de sucessos, pulos e falhas</p>
                </div>

                <h3>Como Funciona? O "Escrivão" e "Repórter" em Ação</h3>
                <p>O componente Operational Logging & Reporting usa o módulo <code>logging</code> embutido do Python, que é perfeito para registrar eventos. Ele executa dois papéis principais:</p>

                <h4>1. O Escrivão (Logging)</h4>
                <p>Como "escrivão," ele registra eventos em um arquivo de texto dedicado chamado <code>transfer_log.txt</code>. Este arquivo é criado na mesma pasta que sua planilha.</p>

                <div class="code-block">
                    <div class="code-header">
                        <i class="fas fa-file-alt"></i>
                        Configuração do Sistema de Log
                    </div>
                    <pre><code>import logging
from pathlib import Path

# Imagine 'caminho_planilha' é "C:\MeusDados\tarefas.xlsx"
caminho_planilha = "C:\\MeusDados\\tarefas.xlsx" # Para nosso exemplo

# 1. Determina onde salvar o arquivo de log
arquivo_log = Path(caminho_planilha).with_name("transfer_log.txt")

# 2. Configura o sistema de logging
logging.basicConfig(
    filename=arquivo_log,       # Onde escrever o log (nosso transfer_log.txt)
    level=logging.INFO,      # Registrar apenas mensagens de nível INFO ou superior
    format="%(asctime)s - %(message)s", # Como cada linha do log deve aparecer
    datefmt="%Y-%m-%d %H:%M:%S", # Formato para o timestamp
    encoding="utf-8"         # Usar UTF-8 para caracteres especiais
)

print(f"Fazendo log para: {arquivo_log}")</code></pre>
                </div>

                <p>Uma vez configurado, o script pode facilmente registrar mensagens:</p>

                <div class="code-block">
                    <div class="code-header">
                        <i class="fas fa-pencil-alt"></i>
                        Exemplos de Registro de Log
                    </div>
                    <pre><code># Durante o loop, quando uma tarefa é pulada:
logging.info(f"[SKIP] Linha 1 já OK — pulando…")

# Quando uma tarefa começa a copiar:
logging.info(f"[2/5] Copiando C:\\Origem\\Arquivo.txt → C:\\Destino\\")

# Quando um erro ocorre:
logging.error(f"Linha 3 erro: Acesso Negado.")</code></pre>
                </div>

                <p><strong>Exemplo de conteúdo do <code>transfer_log.txt</code>:</strong></p>
                <div class="content-box">
                    <pre><code>2025-07-04 20:45:43 - [SKIP] Linha 1 já OK — pulando…
2025-07-04 20:45:43 - [2/2] Copiando C:\Users\hospi\Favorites\TESTE → C:\Users\gabriel.oliveira\Favorites
2025-07-04 20:45:58 - ————————————————————————————————————————————————————— | Resumo: 1 processadas, 1 puladas, 0 erro(s). | Concluído em 15.0 segundos. Planilha e log atualizados.</code></pre>
                </div>

                <h4>2. O Repórter (Reporting)</h4>
                <p>Após todas as transferências serem tentadas, a parte "repórter" compila um resumo final e o apresenta ao usuário. Primeiro, ele coleta as contagens (quantas processadas, puladas, ou erros). Então, cria uma mensagem e a mostra de duas maneiras:</p>

                <div class="professional-list">
                    <ul>
                        <li><strong>No <code>transfer_log.txt</code>:</strong> Como a entrada final no arquivo de log.</li>
                        <li><strong>Como uma janela pop-up:</strong> Uma caixa de mensagem amigável <code>tkinter</code> que aparece na sua tela.</li>
                    </ul>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <i class="fas fa-chart-line"></i>
                        Geração e Exibição do Resumo
                    </div>
                    <pre><code>import time
from tkinter import messagebox
import logging # Já configurado acima

# Imagine que essas contagens são do Orchestrator
processadas = 5
puladas = 2
erros = 1
tempo_inicio = time.perf_counter() - 10 # Simulando 10 segundos de execução

# 1. Calcular tempo decorrido
decorrido = time.perf_counter() - tempo_inicio

# 2. Criar o texto do resumo
resumo = (
    f"\n" +
    f"Resumo: {processadas} processadas, {puladas} puladas, {erros} erro(s).\n" +
    f"Concluído em {decorrido:.1f} segundos. Planilha e log atualizados."
)

# 3. Registrar o resumo no arquivo (em uma linha)
logging.info(resumo.replace("\n", " | "))

# 4. Imprimir o resumo no console (onde você executou o script)
print(resumo)

# 5. Mostrar o resumo em uma janela pop-up
messagebox.showinfo("Transferência Concluída", resumo)</code></pre>
                </div>

                <h3>O Logging & Reporting no main.py</h3>
                <div class="content-box important">
                    <p>No script <code>main.py</code> real, a configuração de logging é feita cedo no script, em uma seção marcada <code>Logging</code>. As chamadas <code>logging.info</code> e <code>logging.error</code> estão espalhadas pelo <code>Loop principal</code> conforme as tarefas são processadas. Finalmente, a criação e exibição do resumo são tratadas na seção <code>Salva e encerra</code>.</p>
                </div>

                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>Seção do Código</th>
                                <th>Função</th>
                                <th>Saída</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Logging (Início)</strong></td>
                                <td>Configura arquivo de log e formato</td>
                                <td>transfer_log.txt criado</td>
                            </tr>
                            <tr>
                                <td><strong>Loop Principal</strong></td>
                                <td>Registra progresso, pulos e erros</td>
                                <td>Entradas detalhadas no log</td>
                            </tr>
                            <tr>
                                <td><strong>Salva e Encerra</strong></td>
                                <td>Compila e apresenta resumo final</td>
                                <td>Pop-up + linha final no log</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3>Benefícios do Sistema de Logging</h3>
                <div class="content-box success">
                    <p><strong>Transparência Total:</strong> Cada operação significativa é registrada com timestamp preciso, proporcionando:
                    <br>• Rastreamento completo de atividades
                    <br>• Identificação rápida de problemas
                    <br>• Histórico para auditorias
                    <br>• Base para melhorias futuras</p>
                </div>

                <div class="professional-list">
                    <ul>
                        <li><strong>Logs Estruturados:</strong> Formato consistente facilita análise automatizada</li>
                        <li><strong>Duplo Canal:</strong> Informações disponíveis tanto no arquivo quanto no console</li>
                        <li><strong>Resumo Executivo:</strong> Pop-up final oferece visão consolidada dos resultados</li>
                        <li><strong>Persistência:</strong> Logs permanecem disponíveis para consulta futura</li>
                    </ul>
                </div>

                <p>Esta configuração abrangente garante que cada execução significativa da automação seja registrada e, no final, um resumo claro seja fornecido ao usuário, tanto no arquivo de log quanto através de uma mensagem pop-up amigável. Isso assegura transparência total e facilita a solução de problemas para todas suas transferências automatizadas.</p>

                <div class="content-box">
                    <p><strong>Conclusão:</strong> O componente <strong>Operational Logging & Reporting</strong> é o registrador diligente e comunicador eficaz do projeto. Usando o módulo <code>logging</code> do Python, ele atua como um "escrivão" para criar um arquivo detalhado <code>transfer_log.txt</code>, registrando cada ação e resultado chave com timestamps. Então, como "repórter," ele compila um resumo claro de tarefas processadas, puladas e com erro, apresentando essa informação crucial tanto no arquivo de log quanto como uma mensagem pop-up amigável.</p>
                </div>

                <p>Com este capítulo, você agora compreende todos os componentes principais do nosso projeto <code>Transfer_automation</code>, desde obter entrada do usuário até executar transferências, lidar com diálogos e, finalmente, registrar e relatar os resultados.</p>

                <p><strong>Isso marca o fim da nossa série tutorial amigável para iniciantes sobre o projeto <code>Transfer_automation</code>!</strong></p>
            </section>
        </div>
    </main>

    <footer class="footer">
        <p>&copy; 2025 Transfer Automation - Todos os direitos reservados. | <a href="https://github.com/WebCash-inc" target="_blank">Visite nosso GitHub</a></p>
    </footer>

    <button id="back-to-top" class="back-to-top" aria-label="Voltar ao topo da página">
        <i class="fas fa-arrow-up"></i>
    </button>

    <script src="https://unpkg.com/mermaid@10.9.1/dist/mermaid.min.js"></script>
    <script src="script.js"></script>
    
    <script>
        // Smooth scroll to top and show/hide button logic
        const backToTopBtn = document.getElementById('back-to-top');

        backToTopBtn.addEventListener('click', () => {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        });

        window.addEventListener('scroll', () => {
            if (window.scrollY > 300) {
                backToTopBtn.classList.add('show');
            } else {
                backToTopBtn.classList.remove('show');
            }
        });

        // Reading Progress Bar Logic
        const progressBar = document.getElementById('reading-progress-bar');
        
        window.addEventListener('scroll', () => {
            const totalHeight = document.body.scrollHeight - window.innerHeight;
            const scrollProgress = (window.scrollY / totalHeight) * 100;
            progressBar.style.width = scrollProgress + '%';
        });
    </script>
</body>
</html>